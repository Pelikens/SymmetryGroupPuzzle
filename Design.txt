Some design thoughts...

The puzzle is a set of static meshes.  Most form the physical part of the puzzle.  The rest are used to capture those
physical parts.  Associated with each of the former are local-to-world transforms used for drawing.  If all are
identity, the puzzle is solved.  Associated with each of the latter are a set of symmetries (transforms) that are
applied to the physical meshes if they, in world space, overlap a capture mesh.  No physical mesh will straddle a
capturing mesh.  If a single point in a physical mesh (any point) is inside a capturing mesh, then the capturing mesh
covers the entire physical mesh.  This is insured by the way the puzzle was cut and the symmetries were computed.
Accumulated round-off error may be an issue, even if we continually re-orthonormalize the transforms, but it may be
accurate enough.

A script will generate the content for a single puzzle in the form of one or more JSON files.  This is the crux of the
implementation.  The script has to perform all the needed cuts and generate all of the triangle meshes.

We may want to animate the puzzle mutations.  To do this, we may need to real-time interpolate transforms.  This isn't
too hard a problem if they are rigid-body transforms.  A timer function could call our draw function as long as there
are animation transforms that haven't caught up with their target transforms.  To avoid any further round-off error, the
animation transform should be assigned the target transform when ready.

Learn to use JS math/matrix library for WebGL?

After giving it a great deal of thought, pre-cutting the puzzle is not a trivial problem to solve.
What I would do is stamp the border and cut-shapes in a graph, then for randomly chosen cut-shapes,
copy all edges of the graph contained in the chosen shape's interior (not border), have the copies undergo a
random symmetry of the chosen shape, then add the transformed copies to the graph without duplicating any existing
edges.  Do this a lot.  There is no clear stopping condition for this algorithm.  At some point, no more edges can
possibly be added to the graph.  Now pick out all empty cycles of the graph as polygons and tessellate those polygons.
(Note that even if two cut-shapes don't overlap, they can still cut one another.)  Though random, the above description
of an algorithm might converge rather quickly, even if many highly disjoint pairs of cut-shapes cut one another.
We can't detect the convergence, but we can be reasonably assured of it if after several iterations, no more edges have
been added to the graph.