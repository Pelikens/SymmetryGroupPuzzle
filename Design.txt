Some design thoughts...

The puzzle is a set of static meshes.  Most form the physical part of the puzzle.  The rest are used to capture those physical parts.  Associated with each of the former are local-to-world transforms used for drawing.  If all are identity, the puzzle is solved.  Associated with each of the latter are a set of symmetries (transforms) that are applied to the physical meshes if they, in world space, overlap a capture mesh.  No physical mesh will straddle a capturing mesh.  If a single point in a physical mesh (any point) is inside a capturing mesh, then the capturing mesh covers the entire physical mesh.  This is insured by the way the puzzle was cut and the symmetries were computed.  Accumulated round-off error may be an issue, even if we continually re-orthonormalize the transforms, but it may be accurate enough.

A script will generate the content for a single puzzle in the form of one or more JSON files.  This is the crux of the implementation.  The script has to perform all the needed cuts and generate all of the triangle meshes.

We may want to animate the puzzle mutations.  To do this, we may need to real-time interpolate transforms.  This isn't too hard a problem if they are rigid-body transforms.  A timer function could call our draw function as long as there are animation transforms that haven't caught up with their target transforms.  To avoid any further round-off error, the animation transform should be assigned the target transform when ready.

Learn to use JS math/matrix library for WebGL?